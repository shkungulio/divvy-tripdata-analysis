---
title: "Divvy Tripdata Database"
output: 
  html_document:
    theme:
      bg: "#101010"
      fg: "#FDF7F7" 
      primary: "#3A97D3"
      base_font:
        google: Montserrat
      code_font:
        google: JetBrains Mono
    highlight: espresso
    css: "resources/styles.css"
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: true
      smooth_scroll: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

#Install the following libraries if required
if(!requireNamespace("RPostgres", quietly = TRUE)){
  # If not installed, then install it
  install.packages("RPostgres")
}
if(!requireNamespace("DBI", quietly = TRUE)){
  # If not installed, then install it
  install.packages("DBI")
}
if(!requireNamespace("ini", quietly = TRUE)){
  # If not installed, then install it
  install.packages("ini")
}

# Install necessary libraries
library(RPostgres)
library(DBI)
library(ini)
library(readr)
library(glue)
```

## Introduction
To investigate ride behavior differences between casual and member users and uncover temporal and spatial patterns in ride activity, a comprehensive and well-structured database is essential. The analysis focuses on understanding how ride patterns vary across time—daily, weekly, and seasonally—and space—stations and routes—while identifying trends in ride duration, station popularity, and overall demand. These insights are critical for guiding Divvy’s operational decisions and marketing strategies.

The source data for this project consists of 12 monthly Divvy trip datasets for the year 2024, containing ride-level information such as ride identifiers, timestamps, start and end stations, and user type (casual vs. member). To efficiently support analysis, a relational database will be designed to:

* Consolidate the monthly datasets into a single, queryable structure.
* Maintain data integrity with primary keys and appropriate data types for timestamps, text fields, and identifiers.
* Enable temporal analysis by storing ride start and end times in a standardized timestamp format.
* Support spatial analysis by including station names and IDs, allowing examination of station popularity and route patterns.
* Facilitate user segmentation by distinguishing between casual and member riders.

By implementing this database, analysts will be able to efficiently query and aggregate data, uncover patterns in ride behavior, and generate actionable insights for Divvy’s operational planning and marketing initiatives.


## Divvy Database Creation

### Database connection
Establish postgresql database connection
```{r db_connection}
# Read config
config <- read.ini("resources/db_config.ini")
db <- config$postgresql

# Safe database connection
tryCatch({
  con <- dbConnect(
    Postgres(),
    host = db$host,
    dbname = db$database,
    user = db$user,
    password = db$password,
    port = as.integer(db$port)
  )
}, error = function(e) {
  stop("Database connection failed: ", e$message)
})

# Register connection for SQL chunks
knitr::opts_chunk$set(connection = con)
```

### Database schema
Create database schema to the database
```{sql create_schema}
CREATE SCHEMA IF NOT EXISTS divvy;
```

### Database tables
Read data into R environment
```{r read_data}
# Define year and months
year <- "2024"
months <- sprintf("%02d", 1:12)

# Initialize list to store data
divvy_data <- list()

# Loop through months and read each file
for (m in months) {
  file_path <- paste0("resources/data/", year, m, "-divvy-tripdata.csv")
  month_name <- tolower(format(as.Date(paste0(year, "-", m, "-01")), "%B"))
  
  divvy_data[[month_name]] <- read_csv(file_path, show_col_types = FALSE)
}
```

Drop tables if already exists
```{r drop_monthly_tables, message=FALSE}
# Define all month names
months <- tolower(month.name)

for (m in months) {
  sql <- glue::glue("DROP TABLE IF EXISTS divvy.{m};")
  DBI::dbExecute(con, sql)
}
```

#### January table
Create and load data for the month of January
```{r jan_table, message=FALSE}
# Create table
create_jan_table <- "
  CREATE TABLE divvy.january (
      ride_id             TEXT PRIMARY KEY,
      rideable_type       TEXT,
      started_at          TIMESTAMP,
      ended_at            TIMESTAMP,
      start_station_name  TEXT,
      start_station_id    TEXT,
      end_station_name    TEXT,
      end_station_id      TEXT,
      member_casual       TEXT
  );
"
DBI::dbExecute(con, create_jan_table)

# Write to PostgreSQL (replaces table if exists)
dbWriteTable(
  conn      = con,
  name      = DBI::Id(schema = "divvy", table = "january"),
  value     = divvy_data$january,
  overwrite = TRUE,   # drop & recreate table
  row.names = FALSE
)
```

#### February table
Create and load data for the month of February
```{r}
# Months we want to load
months <- names(divvy_data)   # "january", "february", ... "december"

for (month_name in months) {
  
  # SQL to create the table
  create_sql <- glue("
    CREATE TABLE divvy.{month_name} (
        ride_id             TEXT PRIMARY KEY,
        rideable_type       TEXT,
        started_at          TIMESTAMP,
        ended_at            TIMESTAMP,
        start_station_name  TEXT,
        start_station_id    TEXT,
        end_station_name    TEXT,
        end_station_id      TEXT,
        member_casual       TEXT
    );
  ")
  
  # Drop if already exists, then create fresh table
  DBI::dbExecute(con, glue("DROP TABLE IF EXISTS divvy.{month_name};"))
  DBI::dbExecute(con, create_sql)
  
  # Write corresponding R dataframe into PostgreSQL
  dbWriteTable(
    conn      = con,
    name      = DBI::Id(schema = "divvy", table = month_name),
    value     = divvy_data[[month_name]],
    overwrite = TRUE,   # ensures table is replaced if already exists
    row.names = FALSE
  )
  
}
```












### Database views
```{sql}
SELECT COUNT(*) FROM divvy.january;
```
```{sql}
SELECT COUNT(*) FROM divvy.february;
```

```{sql}
SELECT COUNT(*) FROM divvy.june;
```
```{sql}
SELECT COUNT(*) FROM divvy.november;
```
```{sql}
SELECT COUNT(*) FROM divvy.december;
```

### Database functions



## Exploratory Data Analysis



## Conclusion





```{r disconnect, include=FALSE}
dbDisconnect(con)
```